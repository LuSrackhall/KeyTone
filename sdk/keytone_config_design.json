// 整个配置文件, 采用下划线命名, 不可采用驼峰命名的形式(即使采用了, 也不会区分大小写)
{
  // 键音包名称
  "package_name": "示例键音包",

  // 原始音频文件列表，以别名为键
  "audio_files": {
    "sound_alias1": "sound1.mp3", // 别名: 原始音频文件名(用于索引当前包内可用的声音文件)
    "sound_alias2": "sound2.mp3",
    "sound_alias3": "sound3.ogg"
  },

  // 定义音频。 ->  这个步骤, 是制作最终按键声音的必要过程。
  // > 我们在此步骤中, 裁剪原始音频文件以定义出我们需要的音频, 并且定义一些最基本的音频参数, 如音量。 (在后续步骤制作键音时, 我们会引用当前步骤中定义的音频)
  "definition_audios": {
    // 自定义音频的名称: 值对象
    // ***********************************************************************************************************************************************
    // * 自定义音频的名称: 用户可自行在key_sound_name_1 后, 设置名称为down或up(如key_sound_name_1_down和key_sound_name_1_up)。 官方不对此做强制干涉。
    // * 值对象: 用于定义当前音频
    //   * audio_file: 指定自定义音频所依赖的音频文件(必选)
    //   * cut: 指定自定义音频对所依赖音频文件的裁剪参数(可选) ( 若未指定, 则播放整个音频文件。)
    //     * start: 开始时间(单位为毫秒)
    //     * end: 结束时间(单位为毫秒)
    //   * volume: 指定自定义音频的音量(这个值是一个浮点数字, 0代表原始音量, 大于0的数字代表放大音量, 小于0的数字代表降低音量, 音频包制作者可酌情使用)
    //   * group: 指定分组, 主要用于更方便的分类管理键音包内, 用户所定义的音频。
    "key_sound_name_1": {
      "audio_file": "原始声音文件",
      "cut": { "start": 0, "end": 123 },
      "volume": 5,
      "group": "" // 为了使键音包更容易管理, 引入group机制
    },
    "key_sound_name_2": {
      "source_sound_path": "原始声音路径",
      "cut": { "start": 130, "end": 253 },
      "volume": 5,
      "group": "" // 为了使键音包更容易管理, 引入group机制
    }
  },

  // 定义按键声音。 ->  这个步骤, 制作的就是最终可用的按键声音。
  // > 按键声音定义时只能依赖上一步骤中定义的音频, 而不能向定义音频时一样, 依赖原始音频文件列表。   (后续可能扩展定义规则, 使得定义键音时可以依赖一个已有定义的键音, 即键音嵌套功能。)
  "definition_key_sounds": {
    // 自定义按键声音的名称: 值对象
    // ***********************************************************************************************************************************************
    // * 自定义按键声音的名称: 名字可以随便取。
    //   > 比如:
    //     1. 可以定义一个"全局按键"的"单一按键音", 或一个"全局按键"的"随机按键音"。
    //     2. 可以定义一个"独立按键"的"单一按键音", 或一个"独立按键"的"随机按键音"
    // * 值对象: 每个按键声音中, 自带down 和 up 声音。
    //   > 当然:
    //     1.若不对其添加音频, 则不会有声音;
    //     2.若仅指定一个音频, 则无论mode如何指定, 则都只会播放这一个音频;
    //     3.若指定了多个音频, 每次也只会触发其中一个, 触发方案按照mode进行。
    //   * down: 用于指定按下时的播放的音频。
    //     * mode: 可选的模式有"随机"和"顺序循环"两种。(仅当value数组的元素数, 大于1时有效。)
    //     * value: 用于定义音频依赖  (后续 音频依赖 可能会扩展到 键音依赖, 即支持键音嵌套)
    //   * up: 用于指定抬起时的播放的音频。
    //     * mode: 可选的模式有"随机"和"顺序循环"两种。(仅当value数组的元素数, 大于1时有效。)
    //     * value: 用于定义音频依赖  (后续 音频依赖 可能会扩展到 键音依赖, 即支持键音嵌套)
    //   * group: 指定分组, 主要用于更方便的分类管理键音包内, 用户所定义按键声音。
    //     > 比如:
    //       1. 按照mode分类的分组:
    //          - 用户可以创建一个名为"普通按键声音"的分组, 里面用于存放仅指定了一个音频的按键声音。
    //          - 用户可以创建一个名为"随机按键声音"的分组, 里面用于存放随机模式的按键声音。
    //          - 用户可以创建一个名为"顺序循环按键声音"的分组, 里面用于存放顺序顺和模式的按键声音。
    //       2. 按照"应用方式"分类的分组:
    //          - 用户可以创建一个名为"用于全局按键声音"的分组, 里面用于存放全局默认使用的按键声音(它可能十一个普通按键声音, 或是一个随机按键声音, 或是一个顺序循环的按键声音。)
    //          - 用户可以创建一个名为"用于independent按键声音"的分组, 里面用于存放为按键独立使用而设计的按键声音(它可能十一个普通按键声音, 或是一个随机按键声音, 或是一个顺序循环的按键声音。)
    "random_name_1": {
      "down": {
        "mode": "random", // "random" | "loop"
        "value": []
      },
      "up": {
        "mode": "random", // "random" | "loop"
        "value": []
      },
      "group": "" // 为了使键音包更容易管理, 引入group机制
    }
  },

  // 这里用于指定未独立配置的按键, 所播放的按键音。
  "global": {
    "key_sound": "",
    "down": true,
    "up": true
    // 取消容器: 原因是, 似乎有些伪需求。
    // * 容器本身是为了复用key_sound的, 比如可以在value中指定多个key_sound, 并按照随机或顺序的方式组合。
    // * 比如组合多个随机 key_sound,  然后在使用容器的顺序或随机规则来随机播放这些。(注意, 这种需求是不能使用随机键音来解决的, 但可以使用嵌套的随机键音来解决。)
    // * 但以上的需求, 似乎不太重要, 因为应用场景有限。(更重要的是, 若后续写代码过程中, 能顺便实现了键音嵌套定义功能, 甚至可以覆盖着着定义方式)
  },

  // 这里默认是空对象, 用户每主动配置一个, 就会增加一个。每删除一个或设置为空一个, 就会减少一个。
  "independent": {
    // "key_code": "key_sound"
    "21": {
      "key_sound": "key_sound_name_1", // 只能使用高级键音名称
      "is_down": true, // 是否使能按下时的声音, 默认为true
      "is_up": true // 是否使能抬起时的声音, 默认为true
    }
  }
}
