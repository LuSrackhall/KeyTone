# 规格增量：专辑配置加密

## 新增需求

### 需求：专辑配置加密触发

规范性：系统应当（SHALL）在前端调用独立加密 API `POST /encrypt_album_config` 时将专辑的 `package.json` 内容加密（将明文 JSON 替换为 AES-GCM 十六进制密文）；未签名专辑必须（MUST）保持明文。

#### 场景：需要签名时调用加密 API

- **给定** 明文专辑配置且用户在导出流程中选择"需要签名"
- **当** 前端在调用导出路由前先调用 `POST /encrypt_album_config`
- **则** 原始 `package.json` 文件内容被十六进制编码的密文替换，后续加载使用降级解密

#### 场景：无需签名时跳过加密

- **给定** 明文专辑配置且用户选择"无需签名"
- **当** 导出完成
- **则** 文件保持可读的 JSON 格式

### 需求：确定性密钥派生

规范性：加密密钥应当（SHALL）通过 SHA256(固定密钥 + last6(sha1(albumUUID))) 派生，产生 32 字节的 AES-GCM 密钥；固定密钥字符串必须（MUST）为 `LuSrackhall_KeyTone_2024_Signature_66688868686688`。

#### 场景：有效的密钥生成

- **给定** 专辑 UUID 存在于配置中的 `audio_pkg_uuid` 字段或目录名
- **当** 密钥派生执行
- **则** 输出长度为 32 字节且在多次运行中保持稳定

### 需求：降级加载与临时挂载

规范性：加载逻辑应当（SHALL）在读取 `package.json` 时识别指示 JSON（包含 `_keytone_core`）或十六进制密文；若检测到指示 JSON，则读取同目录的 `core` 文件，并在解密成功后将明文写入临时目录交由 Viper 加载；解密失败必须（MUST）中止加载（Viper 置空）并记录错误。

#### 场景：成功降级

- **给定** 一个使用指示 JSON + `core` 存储的专辑
- **当** LoadConfig 运行
- **则** 它读取指示 JSON、解密 `core`、写入临时 JSON，并让 Viper 正常提供设置

#### 场景：解密失败

- **给定** 损坏的 `core` 文件或指示 JSON 缺失字段
- **当** LoadConfig 运行
- **则** 它记录错误且不暴露部分设置

### 需求：写回重新加密

规范性：通过 `SetValue` 所做的更改必须（MUST）重新加密更新后的 JSON 并原子覆盖 `core` 文件（写临时文件 + 重命名）而不暴露明文；`package.json` 指示 JSON 内容保持最小化且不得写回明文。

#### 场景：更新持久化为加密

- **给定** 通过降级加载的加密专辑
- **当** 设置被更改并写入
- **则** 源目录下 `core` 文件内容发生变化，解密后可看到更新后的 JSON

### 需求：导入支持加密配置

规范性：专辑导入结构验证必须（MUST）接受包含指示 JSON + `core` 文件的专辑结构，并在解密后验证 JSON 架构与预期字段匹配。

#### 场景：导入加密专辑

- **给定** 一个专辑目录包含指示 JSON `package.json` 与二进制 `core`
- **当** 导入验证执行
- **则** 它解密并无错误地验证结构

### 需求：调试配置打印 CLI

规范性：独立 CLI 工具应当（SHALL）接受 `--path <albumDir>` 并将解密后的 JSON 打印到标准输出；使用 `--raw` 时必须（MUST）打印原始十六进制密文；错误时必须（MUST）以非零状态退出。

#### 场景：明文专辑打印

- **给定** 明文配置
- **当** 工具运行
- **则** 它直接打印 JSON

#### 场景：加密专辑打印

- **给定** 加密配置
- **当** 工具运行
- **则** 它解密并打印 JSON

#### 场景：原始输出模式

- **给定** 加密配置和 `--raw` 标志
- **当** 工具运行
- **则** 它打印密文十六进制字符串

### 需求：向后兼容

规范性：现有未签名专辑应当（SHALL）继续加载并行为不变；加密逻辑必须不（MUST NOT）显著改变明文行为或性能。

#### 场景：旧版专辑不受影响

- **给定** 不需要签名的明文专辑
- **当** 功能部署后加载
- **则** 行为和性能与先前实现一致

### 需求：原子加密写入

规范性：加密文件更新必须（MUST）通过写临时文件 + 重命名执行，以防崩溃时部分写入密文。

#### 场景：原子写入

- **给定** 对加密配置的更新
- **当** 写回执行
- **则** 创建临时文件并重命名；观察者永远不会读取部分密文

### 需求：独立加密 API 路由

规范性：系统应当（SHALL）提供 `POST /encrypt_album_config` 路由，接受 JSON 体 `{ "albumPath": string }`；当目录存在且配置为明文时，加密后返回 `encrypted: true`；当已加密时返回 `already_encrypted: true`；当路径无效或缺失时必须（MUST）返回 4xx 错误。调用方为前端，仅在用户选择"需要签名"时在导出前调用。

#### 场景：前端调用加密 API 成功

- **给定** 明文专辑目录路径 `albumPath`
- **当** 前端调用 `POST /encrypt_album_config` 且提供该路径
- **则** 后端将对应目录下的 `package.json` 加密为十六进制密文并返回 200 成功

#### 场景：重复调用加密 API 幂等

- **给定** 已经加密的 `package.json`
- **当** 前端再次调用 `POST /encrypt_album_config`
- **则** 后端检测已加密并返回 200，与 `already_encrypted: true`

#### 场景：路径缺失或无效

- **给定** 请求未提供 `albumPath` 或路径不存在
- **当** 前端调用 `POST /encrypt_album_config`
- **则** 后端返回 400 错误并提示路径无效
