# 设计：专辑配置加密

## 背景

专辑（音频包）当前以明文 `package.json` 存储配置。当用户在导出时选择签名，我们希望将存储转换为加密形式，同时保持旧版未签名专辑不受影响。

## 目标

- 透明加载：调用方使用现有 `LoadConfig` 无需分支判断。
- 每个专辑使用确定性密钥；最小化派生逻辑。
- 原子写回，确保加密文件不会部分写入。
- 通过 CLI 提供调试可观测性。

## 非目标

- 强加密安全性（固定密钥 + 截断哈希弱于最佳实践）。
- 密钥轮换或升级已加密配置。

## 密钥派生

公式（假设 albumUUID 可从 `audio_pkg_uuid` 字段或目录名获取）：
1. 计算专辑 UUID 字符串的 SHA-1：`H = sha1(albumUUID)`（十六进制字符串 40 字符）。
2. 取后 6 个字符：`S = H[34:40]`。
3. 拼接固定密钥字符串 `LuSrackhall_KeyTone_2024_Signature_66688868686688` + `S` → `Kseed`。
4. 派生 32 字节 AES 密钥：`key = SHA256(Kseed)`（取完整 32 字节）。
5. 使用 AES-GCM，每次加密使用随机 nonce。将密文以二进制形式写入同目录文件 `core`（无后缀、固定命名）。`package.json` 将被替换为仅包含元数据的指示 JSON（例如 `_keytone_encrypted: true`、`_keytone_core: "core"`、`_keytone_schema: "kcfg-core-v1"`），不再承载真实配置。

## 文件生命周期

- 加密触发：前端在用户选择"需要签名"后，调用独立 API `POST /encrypt_album_config`（携带 `albumPath`）加密对应专辑配置。若配置已加密则返回成功；若未加密则将明文转换为 `core` 二进制文件并写回指示 JSON。
- 导入：读取专辑目录时，若 `package.json` 存在但 JSON 解析失败，则视为加密文件并尝试解密。
- Viper 集成：加载前先解析 `package.json`。若检测到指示 JSON，则读取 `core`，解密到临时目录（如 `<os.TempDir()>/keytone-album/<uuid>/package.json.dec`），将 Viper 指向该临时 JSON 并继续监听。配置变更时（SetValue / WriteConfig），读取临时 JSON，重新加密写入 `core`（原子写入 `.tmp` 后重命名），指示 JSON 维持最小内容。
- 解密失败：记录警告，中止加载，设置 Viper = nil 以标识无效专辑。

## 调试 CLI

`go run ./audioPackage/cmd/printconfig -path <albumDir>`
行为：
- 自动检测加密/明文。
- 将解密后的 JSON 打印到标准输出。
- 错误时退出非零，支持 `--raw` 转储原始密文十六进制。

## 决策

- 保持相同文件名以避免修改枚举 `package.json` 的现有代码。
- 直接使用 SHA256 而非 PBKDF2（简化；无用户提供的密码）。
- 存储密文十六进制以简化存在性检测（首字符非 '{'且仅十六进制字符 → 加密）。

## 考虑过的替代方案

- 单独扩展名（如 `package.enc.json`）—— 被拒绝（改动过于侵入）。
- 使用 PBKDF2 迭代 —— 被拒绝（不必要的复杂性；固定密钥已限制收益）。

## 风险 / 缓解措施

- 嵌入密钥导致弱安全性：文档明确说明；目的是混淆而非强加密。
- 意外配置损坏：使用原子重命名；添加校验和验证测试。
- Viper 竞态条件：使用已有的 RWMutex 保护。

## 迁移计划

1. 实现密钥派生辅助函数和加解密工具。
2. 在 `LoadConfig` 中添加检测和降级。
3. 集成独立加密 API 路由供前端调用。
4. 提供 CLI 和测试。
5. 发布；明文专辑继续工作；加密专辑自动加载。

## 待确认问题

- 是否在降级触发时记录日志？（是，在 INFO 级别记录一次。）
- 导出后是否保留原始明文？（否；用加密内容覆盖。）
