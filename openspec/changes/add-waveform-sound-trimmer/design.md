# Design: 波形可视化裁剪（Sound Trimmer with Waveform）

## 背景与问题

现有裁剪仅提供毫秒级 start/end 输入。用户缺少“声音分布”的可视化线索，导致：
- 需要反复预览试错才能定位片段；
- 难以快速找到有声段、瞬态（click）、静音段；
- 新用户不知道音频长度与有效区间。

## 设计目标

- **可视化**：展示波形，让用户一眼看到音量起伏与可能的有效区间。
- **可操作**：拖拽选择区间（region），并能精细调整边界。
- **不破坏现有流程**：start/end 输入框继续存在并可用。
- **稳定数据来源**：波形渲染不依赖“播放成功与否”。

## 方案选型

### 方案 A（已确认 / MVP）：后端提供音频流 + 前端解码渲染

- 后端：提供按 `sha256+type` 定位的音频读取接口，返回音频文件 bytes（带上正确 Content-Type）。
- 前端：使用 WebAudio 解码音频，波形组件完成采样与绘制。

优点：
- 实现速度快，前端生态成熟（例如 wavesurfer.js）。
- 无需在 Go 侧实现复杂音频解码与抽样算法。

风险/注意：
- 大文件解码开销较大，需要 loading + 可能的缓存。
- 需要确保 Electron 渲染进程能请求到本地 SDK HTTP 服务（同源/CORS）。

### 方案 B（后续优化）：后端预计算波形峰值（peaks）

- 后端：返回固定采样率的峰值数组（min/max 或 RMS），并可按 zoom 范围分页。
- 前端：仅绘制与交互，不做解码。

优点：
- 性能稳定，可控；对超长音频更友好。

代价：
- Go 侧需要解码多格式音频并实现抽样/缓存（或引入外部工具/库），复杂度与维护成本更高。

## 交互与数据同步

- 波形组件维护一个选区 `[startMs, endMs]`。
- 与现有输入框双向绑定：
  - 用户拖拽选区边界 -> 更新 start/end 输入框。
  - 用户编辑 start/end 输入框 -> 更新选区边界。

### 右键拖拽快速选区（无菜单）

- 背景：当 start/end 接近 0 且两个手柄重叠时，纯拖拽很难“拉开”选区。
- 交互（无菜单）：
  - 右键按下瞬间：将鼠标所在时间点设置为 start；
  - 右键按下后向右拖动：实时更新 end；
  - 松开右键：将松开位置作为 end。
- 可见性要求：在高缩放（zoom 很大、scrollWidth 很大）时，完成右键选区后 UI SHOULD 立即可见新选区；
  若第三方库/插件存在重绘时序问题，允许在 finalize 后触发一次轻量重绘并将选区滚动到视野内。
- 拖动过程可见性：从右键按下开始到松开结束的全过程，UI SHOULD 持续显示选区范围；
  当指针靠近视窗左右边缘时，可触发“边缘自动滚动”以跟随 end（类似剪辑软件），并应对重绘做节流/合并（例如 requestAnimationFrame）。
- 同类场景推广：播放头拖拽与选区两侧指针拖拽也 SHOULD 采用同样的边缘触发自动滚动手感，
  以保证高 zoom 下拖拽到视野外区域时依然顺滑。
  - 若第三方库内部拖拽逻辑依赖 pointermove，可在自动滚动时派发 synthetic pointermove（best-effort），
    使播放头/选区在滚动中持续更新。
  - 播放头拖拽时可直接 setTime 来保证“滚动后播放头仍跟随光标”，避免跳跃不跟手。
  - 选区两侧指针拖拽时，可在自动滚动中直接 setOptions 更新 region（start/end 跟随光标），
    以避免内部拖拽逻辑滞后导致“指针不跟手”。
  - 在边缘渐进区（滚动速度很小）也应持续更新光标对应的时间点；
    不应仅在 scrollLeft 变化达到阈值时才更新，否则指针会卡在边缘临界线。
  - 播放头/选区指针在拖拽过程中应在每次 pointermove 与自动滚动帧内都更新一次（保持全程跟手）。
  - 为避免内部拖拽与自动滚动冲突，可由组件“接管”左键拖拽流程：
    根据指针命中元素判定拖拽类型（播放头/选区/左右指针），并自行更新播放头/region。
  - 自动滚动速度建议做平滑（例如一阶低通），避免速度抖动造成“跟手不丝滑”。
  - 自动滚动帧内应使用“预测的 scrollLeft”计算光标时间点，保证滚动与位置同步。
  - 命中判定建议使用事件的 composedPath + `part` token（region / region-handle-left/right），
    避免 DOM 结构变化导致无法识别拖拽类型。
- 约束：
  - 不引入最小选区长度（用户明确不需要）；
  - 为避免浏览器默认右键菜单打断交互，波形区域需要禁用 context menu。

#### 两端指针可调整（仅保留可拖动指针版本）

- 目标：选区两侧的指针（start/end）应始终可拖动调整。
- 实现策略：即使逻辑上出现 `start==end`（例如右键按下瞬间、或用户正在逐个输入 start/end 造成暂时 `end<=start`），
  UI 渲染层 SHOULD 将其非零化为一个极小的区间（例如 1ms），确保 Regions 插件进入“带两侧手柄”的 region 形态。
- 说明：这属于渲染层的可操作性保障，不等价于业务层的“最小裁剪长度限制”。

#### 时间映射（点击位置 -> 时间点）

- 目标：右键按下的瞬间，start 时间点 SHALL 与用户视觉点击位置一致。
- 实现要点：在 zoom/横向滚动存在时，必须使用正确的滚动视窗进行映射。
  - 若错误使用“可视区域宽度”作为分母，会把时间算得异常靠后（用户反馈）。
  - 推荐使用 DOM 的 `scrollLeft/scrollWidth` 进行稳定映射，避免依赖第三方库 API 在不同版本/后端下的语义差异。
  - 公式：`time = (xInView + scrollLeft) / scrollWidth * duration`（并对 [0,duration] clamp）。
- 若能获取音频总时长 `durationMs`：
  - clamp：`0 <= start < end <= duration`。
  - 可提供“贴合静音边界/对齐峰值”的增强，但不作为 MVP 必需。

## 体验打磨（本轮增强）

### 缩放 / 滚动

- 提供可调缩放（zoom），使用户能观察并定位到约 `100ms` 级别的片段边界。
- 波形宽度随 zoom 增大而变长，并支持横向滚动；播放时可自动滚动以保证播放头可见。
- 默认 zoom（minPxPerSec）建议为 `50`：先保证整体可读性，再由用户按需放大。
- 交互建议：
  - Slider 控制 zoom（主入口，稳定可发现）；
  - `Ctrl + 鼠标滚轮` 作为快捷缩放（可选增强，需保证体验平滑）。
  - macOS 可根据平台提示：`Control/Command + 滚轮` 或触控板捏合；并使用平台级修饰键识别提高兼容性。

#### 快捷缩放体验（Ctrl + 滚轮）

- 实现 SHOULD 具备：
  - 平滑缩放（建议指数缩放而非固定步进跳变）；
  - 事件节流/合并（例如 requestAnimationFrame），避免触控板高频滚动导致抖动；
  - 以鼠标所在位置为锚点（缩放后该时间点不应大幅漂移），便于精确定位。
  - macOS 上优先使用 getModifierState('Control') 识别外接键盘的 Control 键，必要时允许 Meta 作为兼容兜底。
  - 若 wheel 事件未反映 ctrlKey，可在 window 层记录 Control/Command 按键状态作为兜底。

#### 波形“静音段显示异常”的说明与处理

- 在某些实现中，若开启波形 normalize（把全曲最大峰值拉满高度），高缩放时底噪会被视觉夸张，
  用户会误以为静音段也有明显波形。
- 本轮实现选择：波形显示 SHOULD 默认关闭 normalize，以呈现更贴近真实相对振幅的波形。

### 提示文案与 i18n

- 波形组件将引入“播放/缩放/加载/降级/提示”等新增 UI 文案，这些文案 SHOULD 全部接入 i18n。
- 至少覆盖中文与英文。
- 提示文案 SHOULD 描述“右键拖拽快速选区”等核心能力，并保持跨平台表述（不引入平台特有的操作提示）。

### 前端试听播放条（不依赖 SDK 播放）

- 目的：提供“剪辑软件式”的试听体验：可暂停、可拖动播放头、可选择播放范围。
- 默认播放范围：**播放全部**（从当前播放头位置开始）；也允许用户切换为“播放选区”。
- 不做循环播放（避免 UI 复杂化与误触）。

### 音量一致性

- SDK 的 `cut.volume` 当前用于 `beep/effects.Volume`（Base=1.6 的指数缩放），并非简单 0~1 线性音量。
- 前端试听播放为了尽量贴近 SDK 的听感，应将 `cut.volume` 映射为线性 gain：
  - `gain = 1.6 ^ volume`
  - 若使用 WebAudio backend，可支持 `gain > 1`；为对齐 SDK 预览，前端不应做额外 clamp。

## 音量快捷调节条（剪辑软件风格）

- 在波形区域中间提供一条横向指示线，代表当前 `cut.volume`（0 位于中线）。
- UI SHOULD 明确展示 0 的中位基准线（例如常驻的淡色中线），避免用户将“中位”误解为其它参考值。
- 视觉元素仅保留横线（无额外的圆点手柄），以保持简洁。
- 交互：在指示线附近按下并上下拖动
  - 向上拖动 => 音量增加
  - 向下拖动 => 音量降低
- 该控件与数值输入框双向同步（拖动更新数值，数值更新指示线）。
- 该控件对用户显示 dB（内部仍使用 `cut.volume` 原始尺度）：
  - `gain = 1.6 ^ volume`
  - `dB = 20 * log10(gain) = 20 * volume * log10(1.6)`
- 可视范围建议为 ±18 dB：
  - 超出范围时指示线贴边显示，并给出“普通提示”（非错误/警告），但实际数值保持。
  - 左侧可展示刻度 18/12/6/0/-6/-12/-18；右侧展示当前 dB（可超过 ±18）。
  - 标尺 SHOULD 不压缩波形区域宽度。
    - 推荐实现：左侧刻度数字以 overlay 方式贴在波形左外侧显示（不占布局宽度），并向右对齐至波形边界。
    - 对话框宽度 MAY 适度扩展以容纳标尺，但必须不超过项目固定宽度上限与视口可视范围；
      在固定窗口宽度场景下，应尽可能利用可视空间（避免无意义留白）。
    - 左侧刻度不需要额外单位标识（仅数字），正分贝带 “+” 号；刻度数字应右对齐到波形左边界外侧且无额外间距。
    - 右侧当前值可保留 “dB”，并贴近波形右边界显示；不应添加额外背景装饰。
    - 不需要绘制短刻度线或全宽网格线，仅保留刻度数字即可。
    - 右侧当前 dB 显示应简洁（避免额外背景/装饰）。

### 定位精度（volume=0 与波形中位对齐）

- overlay 的定位范围 SHOULD 与波形绘制区域一致（即 props.height），而非整个容器（可能包含滚动条）。
- 这样 volume=0 的指示线才能精确对齐波形纵向中点。
- 命中区使用像素值定位（而非百分比），避免容器高度差异导致的位置偏移。

### 波形的“音量反馈”（符合直觉的视觉效果）

- 当用户调整音量时，波形本体 SHOULD 产生适度的视觉反馈（例如纵向 scaleY）：
  - 音量增大时波形看起来更“高”；音量减小时更“矮”。
- 该反馈 SHOULD 仅作用于波形绘制层（canvas/svg），不应影响：
  - 选区（Regions）的手柄命中区域
  - 播放头/选区边界的时间对齐
  - 横向滚动/点击位置到时间的映射

#### 技术实现说明（优先使用渲染参数，避免插值伪影）

- wavesurfer.js 的波形渲染来源是“音频采样数据”，不会因 playback volume 自动改变。
- wavesurfer.js 提供渲染阶段的纵向缩放参数（例如 `barHeight`），可用于改变波形渲染高度。
- 实现 SHOULD 优先使用渲染阶段参数并触发重绘，而不是对 canvas 施加 `transform: scaleY(...)`：
  - canvas transform 会产生插值伪影（例如静音中位线变粗/发糊），尤其在最大缩放时更明显。
  - 渲染阶段缩放线条更干净，也更符合“波形高度变化”的直觉。
- barHeight 的更新 SHOULD 做节流/合并（例如 requestAnimationFrame），避免拖动音量时高频重绘导致卡顿。

### 交互稳定性（拖动“时灵时不灵”的处理）

- 命中区 SHOULD 足够大（不应是仅 1~3px 的细线），避免用户误点到波形本体导致事件被第三方库接管。
- 实现 SHOULD 处理 pointercancel / 手势接管等中断场景，以保证拖动不会“突然失效”。

## SDK 预览播放限制（<= 5000ms）

- 背景：SDK 侧预览播放目前缺少可暂停能力，因此不适合承担长片段试听。
- 策略：
  - SDK 预览播放保留，用于验证“最终播放链路”与音量设置的真实性。
  - 但 SDK 预览播放 **严格限制** 仅支持 `<= 5000ms` 的片段；超过即拒绝。
  - 长片段的定位与试听交互，交由前端试听播放条完成。

## 降级策略

- 若音频加载/解码失败：
  - 展示错误提示；
  - 保留 start/end 数字输入与预览/保存功能，保证任务可完成。

## 依赖与许可证

- 候选：wavesurfer.js（BSD-3-Clause）+ Regions/Timeline/Hover 插件。
- 仅在实现阶段确认最终依赖与版本；提案阶段先以“可替换实现”描述需求，避免锁死技术栈。
