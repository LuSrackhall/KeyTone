# Design: 波形可视化裁剪（Sound Trimmer with Waveform）

## 背景与问题

现有裁剪仅提供毫秒级 start/end 输入。用户缺少“声音分布”的可视化线索，导致：
- 需要反复预览试错才能定位片段；
- 难以快速找到有声段、瞬态（click）、静音段；
- 新用户不知道音频长度与有效区间。

## 设计目标

- **可视化**：展示波形，让用户一眼看到音量起伏与可能的有效区间。
- **可操作**：拖拽选择区间（region），并能精细调整边界。
- **不破坏现有流程**：start/end 输入框继续存在并可用。
- **稳定数据来源**：波形渲染不依赖“播放成功与否”。

## 方案选型

### 方案 A（已确认 / MVP）：后端提供音频流 + 前端解码渲染

- 后端：提供按 `sha256+type` 定位的音频读取接口，返回音频文件 bytes（带上正确 Content-Type）。
- 前端：使用 WebAudio 解码音频，波形组件完成采样与绘制。

优点：
- 实现速度快，前端生态成熟（例如 wavesurfer.js）。
- 无需在 Go 侧实现复杂音频解码与抽样算法。

风险/注意：
- 大文件解码开销较大，需要 loading + 可能的缓存。
- 需要确保 Electron 渲染进程能请求到本地 SDK HTTP 服务（同源/CORS）。

### 方案 B（后续优化）：后端预计算波形峰值（peaks）

- 后端：返回固定采样率的峰值数组（min/max 或 RMS），并可按 zoom 范围分页。
- 前端：仅绘制与交互，不做解码。

优点：
- 性能稳定，可控；对超长音频更友好。

代价：
- Go 侧需要解码多格式音频并实现抽样/缓存（或引入外部工具/库），复杂度与维护成本更高。

## 交互与数据同步

- 波形组件维护一个选区 `[startMs, endMs]`。
- 与现有输入框双向绑定：
  - 用户拖拽选区边界 -> 更新 start/end 输入框。
  - 用户编辑 start/end 输入框 -> 更新选区边界。
- 若能获取音频总时长 `durationMs`：
  - clamp：`0 <= start < end <= duration`。
  - 可提供“贴合静音边界/对齐峰值”的增强，但不作为 MVP 必需。

## 降级策略

- 若音频加载/解码失败：
  - 展示错误提示；
  - 保留 start/end 数字输入与预览/保存功能，保证任务可完成。

## 依赖与许可证

- 候选：wavesurfer.js（BSD-3-Clause）+ Regions/Timeline/Hover 插件。
- 仅在实现阶段确认最终依赖与版本；提案阶段先以“可替换实现”描述需求，避免锁死技术栈。
